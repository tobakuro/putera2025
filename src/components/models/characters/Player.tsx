/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/3D/glb/hitogata/hitogata_move.glb -o src/components/models/characters/Player.tsx --types --shadows 
*/

import * as THREE from 'three';
import React from 'react';
import { useGraph } from '@react-three/fiber';
import { useGLTF, useAnimations } from '@react-three/drei';
import { GLTF, SkeletonUtils } from 'three-stdlib';
import { WALK_SPEED } from '../../../constants/player';
import { EnergyWeapon } from '../weapons/EnergyWeapon';

// Minimal GroupProps shape to avoid relying on the global JSX namespace.
export type GroupProps = {
  position?: THREE.Vector3 | [number, number, number] | number;
  rotation?: THREE.Euler | [number, number, number];
  scale?: THREE.Vector3 | [number, number, number] | number;
  /** 移動中なら歩行モーションを再生 */
  play?: boolean;
  children?: React.ReactNode;
  dispose?: unknown;
  [key: string]: unknown;
};

type ActionName = 'アーマチュアアクション';

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GLTFResult = GLTF & {
  nodes: {
    立方体002: THREE.SkinnedMesh;
    Root: THREE.Bone;
  };
  materials: {
    kuro: THREE.MeshStandardMaterial;
  };
  animations: GLTFAction[];
};

export function Model(props: GroupProps) {
  const { play, ...groupProps } = props;
  // useRef must be initialized; allow null until mounted
  const group = React.useRef<THREE.Group | null>(null);
  const weaponRef = React.useRef<THREE.Group | null>(null);
  const { scene, animations } = useGLTF('/models/3D/glb/hitogata/hitogata_move.glb');
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  // useGraph returns a generic map; cast via unknown to satisfy TS for now
  const { nodes, materials } = useGraph(clone) as unknown as GLTFResult;
  // cast group ref to a looser Object3D ref for useAnimations
  const { actions } = useAnimations(animations, group as React.RefObject<THREE.Object3D>);

  // 右手のボーンを見つけて武器をアタッチ
  React.useEffect(() => {
    if (!group.current || !weaponRef.current) return;

    // ボーン構造から右手（右下腕）のボーンを探す
    const bones: THREE.Object3D[] = [];
    group.current.traverse((child) => {
      if (child instanceof THREE.Bone) {
        // このモデルのボーン名: lowerArmR (右下腕)
        const name = child.name.toLowerCase();
        if (
          name === 'lowerarmr' ||
          name === 'lowerarm_r' ||
          name === 'lowerarm.r' ||
          (name.includes('hand') && name.includes('r')) ||
          (name.includes('right') && name.includes('hand')) ||
          name === 'hand.r' ||
          name === 'hand_r' ||
          name === 'righthand' ||
          name.includes('手.r') ||
          name.includes('右手')
        ) {
          bones.push(child);
        }
      }
    });

    // 右手のボーンが見つかったら武器をアタッチ
    const rightHandBone = bones[0];
    const weaponGroup = weaponRef.current;

    if (rightHandBone && weaponGroup) {
      rightHandBone.add(weaponGroup);

      return () => {
        // クリーンアップ: 武器を削除
        rightHandBone.remove(weaponGroup);
      };
    }
  }, []);

  // 再生/停止の切り替え
  React.useEffect(() => {
    const action = actions?.['アーマチュアアクション'];
    if (!action) return;

    // ループ前提の歩行モーション
    // 再生速度倍率: constants/player.ts の WALK_SPEED で調整
    action.setEffectiveTimeScale(WALK_SPEED);

    if (play) {
      // 歩行中: 先頭から再生し続ける
      action.setLoop(THREE.LoopRepeat, Infinity);
      action.reset();
      action.setEffectiveWeight(1);
      action.setEffectiveTimeScale(WALK_SPEED);
      action.fadeIn(0.15);
      action.play();
    } else {
      // 静止中: 歩行アニメの"終了状態"(最終フレーム)で固める
      // NOTE:
      // `react-hooks/immutability` が hook 由来の action へのプロパティ代入を禁止するため、
      // ここだけルールを緩めて three.js の標準的な固定方法を使う。
      /* eslint-disable react-hooks/immutability */
      action.setLoop(THREE.LoopOnce, 1);
      action.setEffectiveWeight(1);
      action.setEffectiveTimeScale(WALK_SPEED);
      // 最終フレームへ移動してから停止（time を play の前に設定）
      const clipDuration = action.getClip().duration;
      action.reset();
      (action as unknown as { time: number }).time = Math.max(0, clipDuration - 1e-3);
      action.clampWhenFinished = true;
      action.paused = true;
      action.play();
      /* eslint-enable react-hooks/immutability */
    }

    return () => {
      // コンポーネント破棄時に停止
      action.stop();
    };
  }, [actions, play]);

  // headPitch は現在未使用（将来的にボーン回転へ反映する場合に追加予定）
  return (
    <group ref={group} {...groupProps} dispose={null}>
      <group name="Scene">
        <group name="アーマチュア">
          <primitive object={nodes.Root} />
          <skinnedMesh
            name="立方体002"
            geometry={nodes.立方体002.geometry}
            material={materials.kuro}
            skeleton={nodes.立方体002.skeleton}
            castShadow
            receiveShadow
          />
        </group>
      </group>
      {/* 武器を右手にアタッチ（位置・回転は右手ボーンに対する相対位置） */}
      <EnergyWeapon
        ref={weaponRef}
        level={4}
        position={[0, -0.3, 0]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={0.8}
      />
    </group>
  );
}

useGLTF.preload('/models/3D/glb/hitogata/hitogata_move.glb');
